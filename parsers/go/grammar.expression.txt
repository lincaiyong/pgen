expression(memo):
    | or_expression
or_expression:
    | lhs=or_expression '||' rhs=and_expression {logical_or_expr(lhs, rhs)}
    | and_expression
and_expression:
    | lhs=and_expression '&&' rhs=compare_expression {logical_and_expr(lhs, rhs)}
    | compare_expression
compare_expression:
    | lhs=compare_expression op=('==' | '!=' | '<' | '<=' | '>' | '>=') rhs=add_op_expression {compare_expr(lhs, op, rhs)}
    | add_op_expression
add_op_expression:
    | lhs=add_op_expression op=('+' | '-' | '|' | '^') rhs=mul_op_expression {add_op_expr(lhs, op. rhs)}
    | mul_op_expression
mul_op_expression:
    | lhs=mul_op_expression op=('*' | '/' | '%' | '<<' | '>>' | '&' | '&^') rhs=unary_expr {mul_op_expr(lhs, op, rhs)}
    | unary_expr
unary_expr:
    | op=('*' | '+' | '-' | '!' | '^' | '*' | '&' | '<-') expr=unary_expr {unary_expr(op, expr)}
    | primary_expr
primary_expr:
    | 'make' '(' '[' ']' type=type ',' len=expression (',' cap=expression)? ','? ')' {make_slice_expr(type, len, cap)}
    | 'make' '(' 'map' '[' k=type ']' v=type (',' hint=expression)? ','? ')' {make_map_expr(k, v, hint)}
    | 'make' '(' 'chan' type=type (',' buffer=expression)? ','? ')' {make_chan_expr(type, buffer)}
    | 'new' '(' type=type ','? ')' {new_expr(type)}
    | callee=(primary_expr|type) type_argument=type_argument_decl? argument=argument_decl {call_expr(callee, type_argument, argument)}
    | expr=primary_expr '.' '(' type=type ')' {type_assert_expr(expr, type)}
    | target=primary_expr '[' low=expression? ':' high=expression? ':' max=expression ']' {full_slice_expr(target, low, high, max)}
    | target=primary_expr '[' low=expression? ':' high=expression? ']' {slice_expr(target, low, high)}
    | target=primary_expr '[' index=expression ']' {index_expr(target, index)}
    | target=primary_expr '.' selector=IDENT {selector_expr(target, selector)}
    | '(' expr=expression ')' {paren_expr(expr)}
    | number=NUMBER {number_expr(number)}
    | string=STRING {string_expr(string)}
    | type=literal_type '{' y=','.keyed_element* ','? '}' {composite_lit(x, y)}
    | _hack_composite_lit_node
    | 'func' x=signature y=block {function_lit(x,y)}
    | x=type '.' y=IDENT {selector_expr(x,y)}
    | i=IDENT {ident(i)}

type_argument_decl:
    | '[' types=','.type+ ','? ']' {type_argument_decl(types)}
argument_decl:
    | '(' arguments=','.argument* ','? ')' {argument_decl(arguments)}
argument:
    | expr=expression '...' {ellipsis_argument(expr)}
    | expr=expression {argument(expr)}