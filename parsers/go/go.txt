#include(token.rule.txt)
------------------------------------------------------------------------------------------------------------------------
#include(token.kw.txt)
------------------------------------------------------------------------------------------------------------------------
#include(token.op.txt)
------------------------------------------------------------------------------------------------------------------------
#include(ast.node.txt)
#include(ast.expr.txt)
#include(ast.stmt.txt)
#include(ast.type.txt)
------------------------------------------------------------------------------------------------------------------------
file: 'package' n=package_ident ';' i=import_decl* t=top_level_decl_semi* END_OF_FILE {file(n, i, t)}

package_ident: n=IDENT {package_ident(n)}

import_decl:
    | 'import' '(' specs=(t=import_spec pseudo_semi {t})* ')' ';'? {import_decl(specs)}
    | 'import' specs=import_spec ';'? {import_decl([specs])}
import_spec: name=(import_dot | import_ident)? path=import_path {import_spec(name, path)}
import_dot: d='.' {import_dot(d)}
import_ident: n=IDENT {import_ident(n)}
import_path: s=STRING {import_path(s)}

top_level_decl_semi: t=top_level_decl ';'? {t}
top_level_decl: function_decl | method_decl | const_decl | var_decl | type_decl

#include(grammar.function.txt)
#include(grammar.const.var.txt)
#include(grammar.type.txt)
#include(grammar.generic.txt)
#include(grammar.statement.txt)
#include(grammar.if.for.txt)
#include(grammar.switch.txt)

expression_stmt: x=expression {expr_stmt(x)}


type:
    | type_name_or_generic_type_instantiation
    | type_lit
    | '(' x=type ')' {paren_expr(x)}
type_name_or_generic_type_instantiation:
    | x=type_name y=generic_args {generic_type_instantiation(x, y)}
    | type_name
type_name: qualified_ident | IDENT
generic_args: '[' s=','.type+ ']' {s}
type_lit:
    | '*' x=type {star_expr(x)}
    | array_type
    | struct_type
    | 'func' x=signature {x}
    | 'interface' b=interface_body {interface_type(b)}
    | map_type
    | channel_type
interface_body: '{' x=method_spec_and_interface_type_name_semi* '}' {field_list(x)}

method_spec_and_interface_type_name_semi:
    | method_spec_semi
    | interface_type_name_semi
    | '|'.('~'? t=type {t})+ pseudo_semi {field(_,_,_)}
method_spec_semi: x=method_spec pseudo_semi {x}
interface_type_name_semi: x=type_name pseudo_semi {field(_,x,_)}

channel_type:
    | t=(a='chan' b='<-' {_pseudo_token(a, b)} | a='<-' b='chan' {_pseudo_token(a, b)} | 'chan') x=type {chan_type(t, x)}

map_type: 'map' '[' x=type ']' y=type {map_type(x,y)}

qualified_ident: x=IDENT '.' y=IDENT { selector_expr(x, y) }

receiver: parameters

identifier_list: x=','.IDENT+ {x}
expression_list: ','.expression+

#include(grammar.expression.txt)

# control clause中限制的只有下面两种情况，这个不在限制中：
#  "x=literal_type y=literal_value {composite_lit(x,y)}"
composite_lit:
    | x=type_name_or_generic_type_instantiation? '{' y=','.keyed_element* ','? '}' {composite_lit(x, y)}

ellipsis: '...' {ellipsis(_)}
literal_type:
    | struct_type
    | '[' e=ellipsis ']' x=type {array_type(e,x)}
    | array_type
    | map_type

keyed_element:
    | x=expression ':' y=expression {key_value_expr(x,y)}
    | expression

array_type:
    | '[' ']' x=type {array_type(_,x)}
    | '[' e=ellipsis ']' x=type {array_type(e,x)}
    | '[' x=expression ']' y=type {array_type(x,y)}

method_spec: x=IDENT y=signature {field([x],y,_)}

struct_body: '{' x=field_decl_semi* '}' {field_list(x)}
struct_type:
    | 'struct' b=struct_body {struct_type(b)}

field_decl_semi: x=field_decl pseudo_semi {x}
field_decl:
    | x=identifier_list y=type z=tag? {field(x,y,z)}
    | x=embedded_field y=tag? {field(_,x,y)}
embedded_field:
    | '*' x=type_name_or_generic_type_instantiation {star_expr(x)}
    | t=type_name_or_generic_type_instantiation {t}
tag: x=STRING {basic_lit(x)}

pseudo_semi: ';' | &')'| &'}'
------------------------------------------------------------------------------------------------------------------------
#include(hack.go.txt)