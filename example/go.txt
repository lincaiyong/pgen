comment:
    | '//' _any_but_eol* | '/*' (!'*/' _any_but_eof)* '*/'
_ident_ch:
    | !_whitespace_ch [a-zA-Z_\u0080-\uFFFF]
ident:
    | _ident_ch (_ident_ch | [0-9])*
string:
    | '`' (!'`' _any_but_eof)* '`'
    | '"' ('\\' _any_but_eof | !'"' _any_but_eol)* '"'
number:
    | '0' [oObBxX] [_0-9a-fA-F.]+ ([pP] [+-]? [_0-9]+)? 'i'?
    | '.' [0-9] ('_'? [0-9])* ([eE] [+-]? [0-9] ('_'? [0-9])*)? 'i'?
    | [0-9] ('_'? [0-9])* '.'? ([0-9] ('_'? [0-9])*)? ([eE] [+-]? [0-9] ('_'? [0-9])*)? 'i'?
    | '\'' ('\\' _any_but_eof | !'\'' _any_but_eol)+ '\''
------------------------------------------------------------------------------------------------------------------------
break
case
chan
const
continue
default
defer
else
fallthrough
for
func
go
goto
if
import
interface
map
package
range
return
select
struct
switch
type
var
------------------------------------------------------------------------------------------------------------------------
!
!=
%
%=
&
&&
&=
&^
&^=
(
)
*
*=
+
++
+=
,
-
--
-=
.
...
/
/=
:
:=
;
<
<-
<<
<<=
<=
=
==
>
>=
>>
>>=
[
]
^
^=
{
|
|=
||
}
~
------------------------------------------------------------------------------------------------------------------------
file                <package import decls>
assign_stmt         <lhs op rhs>
block_stmt          <list>
branch_stmt         <tok label>
decl_stmt           <decl>
defer_stmt          <call>
go_stmt             <call>
send_stmt           <chan value>
expr_stmt           <x>
inc_dec_stmt        <x tok>
if_stmt             <init cond body else>
for_stmt            <init cond post body>
range_stmt          <key value x body tok>
select_stmt         <body>
switch_stmt         <init tag body>
type_switch_stmt    <init assign body>
return_stmt         <results>
binary_expr         <x y op>
call_expr           <fun type_args args>
index_expr          <x index>
key_value_expr      <key value>
paren_expr          <x>
selector_expr       <x sel>
star_expr           <x>
type_assert_expr    <x type>
slice_expr          <x low high max>
unary_expr          <op x>
array_type          <len elt>
chan_type           <dir value>
func_type           <params results>
interface_type      <methods>
map_type            <key value>
struct_type         <x>
basic_lit           <value>
composite_lit       <type elts>
func_lit            <type body>
case_clause         <list body>
common_clause       <common body>
field_list          <list>
field               <names type tag>
import_decl         <x>
import_spec         <name source>
value_spec          <names type values>
type_spec           <name type_params type>
gen_decl            <specs>
func_decl           <recv name type_params type body>
ellipsis            <elt>
labeled_stmt        <label stmt>
generic_type_instantiation        <base args>
------------------------------------------------------------------------------------------------------------------------
file: 'package' n=IDENT ';' i=import_decl* t=top_level_decl_semi* END_OF_FILE {file(n, i, t)}

import_decl:
    | 'import' '(' specs=(t=import_spec end_semi {t})* ')' ';'? {import_decl(specs)}
    | 'import' specs=import_spec ';'? {import_decl([specs])}
import_spec: name=(IDENT | '.')? path=STRING {import_spec(name, path)}

top_level_decl_semi: t=top_level_decl ';'? {t}

block: '{' x=statement_semi_list? '}' {block_stmt(x)}

statement_semi_list: statement_semi+
statement_semi: x=statement end_semi {x}
statement:
    | x=declaration {decl_stmt(x)}
    | labeled_stmt
    | simple_stmt
    | if_stmt
    | type_switch_stmt
    | expr_switch_stmt
    | 'select' b=select_body {select_stmt(b)}
    | for_stmt
    | 'go' x=expression {go_stmt(x)}
    | 'return' x=expression_list? {return_stmt(x)}
    | x='break' y=IDENT? {branch_stmt(x,y)}
    | x='continue' y=IDENT? {branch_stmt(x,y)}
    | x='goto' y=IDENT {branch_stmt(x,y)}
    | x='fallthrough' {branch_stmt(x,_)}
    | 'defer' x=expression {defer_stmt(x)}
    | block

select_body: '{' cases=common_clause* '}' {block_stmt(cases)}

for_stmt:
    | 'for' [ c=expression? ] b=block {for_stmt(_,c,_,b)}
    | 'for' [ i=simple_stmt? ';' c=expression? ';' post=simple_stmt? ] b=block {for_stmt(i,c,post,b)}
    | 'for' [ 'range' x=expression ] b=block {range_stmt(_,_,x,b,_)}
    | 'for' [ k=expression ',' v=expression tok=(':='|'=') 'range' x=expression ] b=block {range_stmt(k,v,x,b,tok)}
    | 'for' [ k=expression tok=(':='|'=') 'range' x=expression ] b=block {range_stmt(k,_,x,b,tok)}

common_clause:
    | 'case' x=send_stmt ':' y=statement_semi_list? {common_clause(x,y)}
    | 'case' x=recv_stmt ':' y=statement_semi_list? {common_clause(x,y)}
    | 'default' ':' x=statement_semi_list? {common_clause(_,x)}
recv_stmt:
    | x=expression_list op='=' y=expression {assign_stmt(x, op, [y])}
    | x=identifier_list op=':=' y=expression {assign_stmt(x, op, [y])}
    | x=expression {expr_stmt(x)}

type_switch_body: '{' cases=type_case_clause* '}' {block_stmt(cases)}
type_switch_stmt:
    | 'switch' [ (init=simple_stmt ';')? assign=type_switch_guard ] b=type_switch_body {type_switch_stmt(init,assign,b)}

type_assert_expr: r=primary_expr '.' '(' 'type' ')' {type_assert_expr(r,_)}
type_switch_guard:
    | l=IDENT op=':=' t=type_assert_expr {assign_stmt([l], op, [t])}
    | t=type_assert_expr {expr_stmt(t)}
type_case_clause:
    | 'case' x=','.type+ ':' y=statement_semi_list? {case_clause(x,y)}
    | 'default' ':' x=statement_semi_list? {case_clause(_,x)}

expr_switch_body: '{' cases=expr_case_clause* '}' {block_stmt(cases)}
expr_switch_stmt:
    | 'switch' [ (init=simple_stmt ';')? tag=expression? ]  b=expr_switch_body {switch_stmt(init,tag,b)}
expr_case_clause:
    | 'case' x=expression_list ':' y=statement_semi_list? {case_clause(x,y)}
    | 'default' ':' x=statement_semi_list? {case_clause(_,x)}

if_stmt:
    | 'if' [ (init=simple_stmt ';')? cond=expression ] body=block 'else' else_=if_stmt {if_stmt(init, cond, body, else_)}
    | 'if' [ (init=simple_stmt ';')? cond=expression ] body=block 'else' else_=block {if_stmt(init, cond, body, else_)}
    | 'if' [ init=simple_stmt ';' cond=expression ] body=block {if_stmt(init, cond, body, _)}
    | 'if' [ cond=expression ] body=block {if_stmt(_, cond, body, _)}

simple_stmt: assignment | short_val_decl | inc_dec_stmt | send_stmt | expression_stmt

expression_stmt: x=expression {expr_stmt(x)}

send_stmt: x=expression '<-' y=expression {send_stmt(x,y)}
inc_dec_stmt: x=expression y=('++'|'--') {inc_dec_stmt(x,y)}
assignment: l=expression_list op=assign_op r=expression_list {assign_stmt(l, op, r)}
assign_op: '=' | '+=' | '-=' | '|=' | '^=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '&^='

short_val_decl: l=identifier_list op=':=' r=expression_list {assign_stmt(l, op, r)}
empty_block: '{' '}' {block_stmt(_)}
labeled_stmt:
    | x=IDENT ':' b=empty_block {labeled_stmt(x,b)}
    | x=IDENT ':' y=statement {labeled_stmt(x,y)}
    | x=IDENT ':' {labeled_stmt(x,_)}

type:
    | type_name_or_generic_type_instantiation
    | type_lit
    | '(' x=type ')' {paren_expr(x)}
type_name_or_generic_type_instantiation:
    | x=type_name y=generic_args {generic_type_instantiation(x, y)}
    | type_name
type_name: qualified_ident | IDENT
generic_args: '[' s=','.type+ ']' {s}
type_lit:
    | '*' x=type {star_expr(x)}
    | array_type
    | struct_type
    | 'func' x=signature {x}
    | 'interface' b=interface_body {interface_type(b)}
    | map_type
    | channel_type
interface_body: '{' x=method_spec_and_interface_type_name_semi* '}' {field_list(x)}

method_spec_and_interface_type_name_semi:
    | method_spec_semi
    | interface_type_name_semi
    | '|'.('~'? t=type {t})+ end_semi {field(_,_,_)}
method_spec_semi: x=method_spec end_semi {x}
interface_type_name_semi: x=type_name end_semi {field(_,x,_)}

channel_type:
    | t=(a='chan' b='<-' {_pseudo_token(a, b)} | a='<-' b='chan' {_pseudo_token(a, b)} | 'chan') x=type {chan_type(t, x)}

map_type: 'map' '[' x=type ']' y=type {map_type(x,y)}

qualified_ident: x=IDENT '.' y=IDENT { selector_expr(x, y) }

top_level_decl: declaration | function_decl | method_decl
declaration:
    | 'const' '(' c=const_spec_semi* ')' {gen_decl(c)}
    | 'const' c=const_spec {gen_decl([c])}
    | 'var' '(' x=var_spec_semi* ')' {gen_decl(x)}
    | 'var' x=var_spec {gen_decl([x])}
    | 'type' '(' x=type_spec_semi* ')' {gen_decl(x)}
    | 'type' x=type_spec {gen_decl([x])}

const_spec: i=identifier_list (t=type? '=' e=expression_list)? {value_spec(i, t, e)}
const_spec_semi: c=const_spec end_semi {c}

generic_type_parameters:
    | '[' ']' {_}
    | '[' x=generic_type_parameter_list ','? ']' {x}
generic_type_parameter_list:
    | x=','.generic_type_parameter_decl+ {field_list(x)}
generic_type_parameter_decl:
    | x=identifier_list y=generic_union_type {field(x,y,_)}
    | x=generic_union_type {field(_,x,_)}

generic_union_type:
    | '|'.generic_atom_type+
generic_atom_type:
    | '~'? x=type {x}
type_spec:
    | x=IDENT t=generic_type_parameters? '='? y=type {type_spec(x, t, y)}
type_spec_semi: x=type_spec end_semi {x}
var_spec:
    | i=identifier_list t=type ('=' e=expression_list)? {value_spec(i, t, e)}
    | i=identifier_list '=' e=expression_list {value_spec(i, _, e)}
var_spec_semi: x=var_spec end_semi {x}

function_decl: 'func' n=IDENT t=generic_type_parameters? s=signature? b=block? {func_decl(_, n, t, s, b)}
signature:
    | x=parameters y=result {func_type(x,y)}
    | x=parameters {func_type(x,_)}

result_field: x=type {field(_,x,_)}
result:
    | parameters
    | r=result_field {field_list([r])}

parameters:
    | '(' ')' {_}
    | '(' x=parameter_list ','? ')' {x}
parameter_list: x=','.parameter_decl+ {field_list(x)}
ellipsis_type: '...' y=type {ellipsis(y)}
parameter_decl:
    | x=identifier_list t=ellipsis_type {field(x,t,_)}
    | x=identifier_list y=type {field(x,y,_)}
    | t=ellipsis_type {field(_,t,_)}
    | x=type {field(_,x,_)}

method_decl: 'func' r=receiver n=IDENT s=signature b=block? {func_decl(r,n,_,s,b)}
receiver: parameters

identifier_list: x=','.IDENT+ {x}
expression_list: ','.expression+

expression(memo):
    | conditional_or_expression
conditional_or_expression:
    | x=conditional_or_expression z='||' y=conditional_and_expression {binary_expr(x,y,z)}
    | conditional_and_expression
conditional_and_expression:
    | x=conditional_and_expression z='&&' y=rel_op_expression {binary_expr(x,y,z)}
    | rel_op_expression
rel_op_expression:
    | x=rel_op_expression z=rel_op y=add_op_expression {binary_expr(x,y,z)}
    | add_op_expression
add_op_expression:
    | x=add_op_expression z=add_op y=mul_op_expression {binary_expr(x,y,z)}
    | mul_op_expression
mul_op_expression:
    | x=mul_op_expression z=mul_op y=unary_expr {binary_expr(x,y,z)}
    | unary_expr
unary_expr:
    | '*' x=unary_expr {star_expr(x)}
    | x=unary_op y=unary_expr {unary_expr(x,y)}
    | primary_expr
primary_expr:
    | x=primary_expr g=generic_args? '(' ')' {call_expr(x,g,_)}
    | x=primary_expr g=generic_args? '(' t=type ',' y=expression_list '...'? ','? ')' {call_expr(x, g, _merge_nodes(t,y))}
    | x=primary_expr g=generic_args? '(' t=type '...'? ','? ')' {call_expr(x, g, _merge_nodes(t,_))}
    | x=primary_expr g=generic_args? '(' y=expression_list '...'? ','? ')' {call_expr(x,g,y)}
    | x=primary_expr '.' '(' y=type ')' {type_assert_expr(x,y)}
    | e=primary_expr '[' l=expression? ':' h=expression ':' m=expression ']' {slice_expr(e,l,h,m)}
    | e=primary_expr '[' l=expression? ':' h=expression? ']' {slice_expr(e,l,h,_)}
    | x=primary_expr '[' y=expression ']' {index_expr(x,y)}
    | x=primary_expr '.' y=IDENT {selector_expr(x, y)}
    | x=type g=generic_args? '(' y=expression ','? ')' {call_expr(x,g,[y])}
    | '(' x=expression ')' {paren_expr(x)}
    | x=NUMBER {basic_lit(x)}
    | x=STRING {basic_lit(x)}
    | x=literal_type '{' y=','.keyed_element* ','? '}' {composite_lit(x, y)}
    | _hack_composite_lit_node
    | 'func' x=signature y=block {func_lit(x,y)}
    | x=type '.' y=IDENT {selector_expr(x,y)}
    | IDENT

rel_op: '==' | '!=' | '<' | '<=' | '>' | '>='
add_op: '+' | '-' | '|' | '^'
mul_op: '*' | '/' | '%' | '<<' | '>>' | '&' | '&^'
unary_op: '+' | '-' | '!' | '^' | '*' | '&' | '<-'

# control clause中限制的只有下面两种情况，这个不在限制中：
#  "x=literal_type y=literal_value {composite_lit(x,y)}"
composite_lit:
    | x=type_name_or_generic_type_instantiation? '{' y=','.keyed_element* ','? '}' {composite_lit(x, y)}

ellipsis: '...' {ellipsis(_)}
literal_type:
    | struct_type
    | '[' e=ellipsis ']' x=type {array_type(e,x)}
    | array_type
    | map_type

keyed_element:
    | x=expression ':' y=expression {key_value_expr(x,y)}
    | expression

array_type:
    | '[' ']' x=type {array_type(_,x)}
    | '[' e=ellipsis ']' x=type {array_type(e,x)}
    | '[' x=expression ']' y=type {array_type(x,y)}

method_spec: x=IDENT y=signature {field([x],y,_)}

struct_body: '{' x=field_decl_semi* '}' {field_list(x)}
struct_type:
    | 'struct' b=struct_body {struct_type(b)}

field_decl_semi: x=field_decl end_semi {x}
field_decl:
    | x=identifier_list y=type z=tag? {field(x,y,z)}
    | x=embedded_field y=tag? {field(_,x,y)}
embedded_field:
    | '*' x=type_name_or_generic_type_instantiation {star_expr(x)}
    | t=type_name_or_generic_type_instantiation {t}
tag: x=STRING {basic_lit(x)}

end_semi: ';' | &')'| &'}'

------------------------------------------------------------------------------------------------------------------------
func (tk *Tokenizer) Clean(tokens []*Token) []*Token {
	ret := make([]*Token, 0)
	var last *Token
	for _, tok := range tokens {
		// insert optional semicolon
		// The formal grammar uses semicolons ";" as terminators in a number of productions. Go programs may omit most of these semicolons using the following two rules:
		//
		// When the input is broken into tokens, a semicolon is automatically inserted into the token stream immediately after a line's final token if that token is
		// an identifier
		// an integer, floating-point, imaginary, rune, or string literal
		// one of the keywords break, continue, fallthrough, or return
		// one of the operators and punctuation ++, --, ), ], or }
		// To allow complex statements to occupy a single line, a semicolon may be omitted before a closing ")" or "}".
		if tok.Kind == TokenTypeNewline {
			if last != nil && last.Kind != TokenTypeOpSemi {
				insertSemi := false
				switch last.Kind {
				case TokenTypeIdent:
					insertSemi = true
				case TokenTypeString:
					insertSemi = true
				case TokenTypeOpRightParen, TokenTypeOpRightBracket, TokenTypeOpRightBrace:
					// ),],}
					insertSemi = true
				case TokenTypeOpPlusPlus, TokenTypeOpMinusMinus:
					// ++,--
					insertSemi = true
				case TokenTypeNumber:
					insertSemi = true
				case TokenTypeKwFallthrough, TokenTypeKwReturn, TokenTypeKwBreak, TokenTypeKwContinue:
					insertSemi = true
				}

				if insertSemi {
					last = NewToken(TokenTypeOpSemi, last.Start, last.End, []rune(";"))
					ret = append(ret, last)
				}
			}
		}

		if tok.Kind == TokenTypeWhitespace || tok.Kind == TokenTypeNewline || tok.Kind == TokenTypeComment {
			continue
		}

		ret = append(ret, tok)
		last = tok
		if tok.Kind == TokenTypeEndOfFile {
			break
		}
	}
	return ret
}

func (ps *Parser) _enter() {
	ps._any = ps._bracketDepth + 1
}

func (ps *Parser) _leave() {
	ps._any = 0
}

func (ps *Parser) _hackCompositeLitNode() Node {
	if ps._any == nil || ps._bracketDepth >= ps._any.(int) {
		return ps.compositeLit()
	}
	return nil
}
