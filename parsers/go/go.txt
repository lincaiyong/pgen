#include(token.rule.txt)
------------------------------------------------------------------------------------------------------------------------
#include(token.kw.txt)
------------------------------------------------------------------------------------------------------------------------
#include(token.op.txt)
------------------------------------------------------------------------------------------------------------------------
#include(ast.node.txt)
------------------------------------------------------------------------------------------------------------------------
file: 'package' n=package_ident ';' i=import_decl* t=top_level_decl_semi* END_OF_FILE {file(n, i, t)}

package_ident: n=IDENT {package_ident(n)}

import_decl:
    | 'import' '(' specs=(t=import_spec pseudo_semi {t})* ')' ';'? {import_decl(specs)}
    | 'import' specs=import_spec ';'? {import_decl([specs])}
import_spec: name=(import_dot | import_ident)? path=import_path {import_spec(name, path)}
import_dot: d='.' {import_dot(d)}
import_ident: n=IDENT {import_ident(n)}
import_path: s=STRING {import_path(s)}

top_level_decl_semi: t=top_level_decl ';'? {t}
top_level_decl: function_decl | method_decl | const_decl | var_decl | type_decl

#include(grammar.function.txt)
#include(grammar.const.var.txt)

type_decl:
    | 'type' '(' x=type_spec_semi* ')' {type_decl(x)}
    | 'type' x=type_spec {type_decl([x])}
type_spec_semi: x=type_spec pseudo_semi {x}
type_spec:
    | x=type_ident t=generic_parameter_decl? '=' y=type {type_eq_spec(x, t, y)}
    | x=type_ident t=generic_parameter_decl? y=type {type_spec(x, t, y)}
type_ident: n=IDENT {type_ident(n)}

#include(grammar.generic.txt)

block: '{' x=statement_semi_list? '}' {block_stmt(x)}

#include(grammar.statement.txt)

select_body: '{' cases=common_clause* '}' {block_stmt(cases)}

for_stmt:
    | 'for' [ c=expression? ] b=block {for_stmt(_,c,_,b)}
    | 'for' [ i=simple_stmt? ';' c=expression? ';' post=simple_stmt? ] b=block {for_stmt(i,c,post,b)}
    | 'for' [ 'range' x=expression ] b=block {range_stmt(_,_,x,b,_)}
    | 'for' [ k=expression ',' v=expression tok=(':='|'=') 'range' x=expression ] b=block {range_stmt(k,v,x,b,tok)}
    | 'for' [ k=expression tok=(':='|'=') 'range' x=expression ] b=block {range_stmt(k,_,x,b,tok)}

common_clause:
    | 'case' x=send_stmt ':' y=statement_semi_list? {common_clause(x,y)}
    | 'case' x=recv_stmt ':' y=statement_semi_list? {common_clause(x,y)}
    | 'default' ':' x=statement_semi_list? {common_clause(_,x)}
recv_stmt:
    | x=expression_list op='=' y=expression {assign_stmt(x, op, [y])}
    | x=identifier_list op=':=' y=expression {assign_stmt(x, op, [y])}
    | x=expression {expr_stmt(x)}

type_switch_body: '{' cases=type_case_clause* '}' {block_stmt(cases)}
type_switch_stmt:
    | 'switch' [ (init=simple_stmt ';')? assign=type_switch_guard ] b=type_switch_body {type_switch_stmt(init,assign,b)}

type_assert_expr: r=primary_expr '.' '(' 'type' ')' {type_assert_expr(r,_)}
type_switch_guard:
    | l=IDENT op=':=' t=type_assert_expr {assign_stmt([l], op, [t])}
    | t=type_assert_expr {expr_stmt(t)}
type_case_clause:
    | 'case' x=','.type+ ':' y=statement_semi_list? {case_clause(x,y)}
    | 'default' ':' x=statement_semi_list? {case_clause(_,x)}

expr_switch_body: '{' cases=expr_case_clause* '}' {block_stmt(cases)}
expr_switch_stmt:
    | 'switch' [ (init=simple_stmt ';')? tag=expression? ]  b=expr_switch_body {switch_stmt(init,tag,b)}
expr_case_clause:
    | 'case' x=expression_list ':' y=statement_semi_list? {case_clause(x,y)}
    | 'default' ':' x=statement_semi_list? {case_clause(_,x)}

if_stmt:
    | 'if' [ (init=simple_stmt ';')? cond=expression ] body=block 'else' else_=if_stmt {if_stmt(init, cond, body, else_)}
    | 'if' [ (init=simple_stmt ';')? cond=expression ] body=block 'else' else_=block {if_stmt(init, cond, body, else_)}
    | 'if' [ init=simple_stmt ';' cond=expression ] body=block {if_stmt(init, cond, body, _)}
    | 'if' [ cond=expression ] body=block {if_stmt(_, cond, body, _)}

simple_stmt: assignment | short_val_decl | inc_dec_stmt | send_stmt | expression_stmt

expression_stmt: x=expression {expr_stmt(x)}

send_stmt: x=expression '<-' y=expression {send_stmt(x,y)}
inc_dec_stmt: x=expression y=('++'|'--') {inc_dec_stmt(x,y)}
assignment: l=expression_list op=assign_op r=expression_list {assign_stmt(l, op, r)}
assign_op: '=' | '+=' | '-=' | '|=' | '^=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '&^='

short_val_decl: l=identifier_list op=':=' r=expression_list {assign_stmt(l, op, r)}
empty_block: '{' '}' {block_stmt(_)}
labeled_stmt:
    | x=IDENT ':' b=empty_block {labeled_stmt(x,b)}
    | x=IDENT ':' y=statement {labeled_stmt(x,y)}
    | x=IDENT ':' {labeled_stmt(x,_)}

type:
    | type_name_or_generic_type_instantiation
    | type_lit
    | '(' x=type ')' {paren_expr(x)}
type_name_or_generic_type_instantiation:
    | x=type_name y=generic_args {generic_type_instantiation(x, y)}
    | type_name
type_name: qualified_ident | IDENT
generic_args: '[' s=','.type+ ']' {s}
type_lit:
    | '*' x=type {star_expr(x)}
    | array_type
    | struct_type
    | 'func' x=signature {x}
    | 'interface' b=interface_body {interface_type(b)}
    | map_type
    | channel_type
interface_body: '{' x=method_spec_and_interface_type_name_semi* '}' {field_list(x)}

method_spec_and_interface_type_name_semi:
    | method_spec_semi
    | interface_type_name_semi
    | '|'.('~'? t=type {t})+ pseudo_semi {field(_,_,_)}
method_spec_semi: x=method_spec pseudo_semi {x}
interface_type_name_semi: x=type_name pseudo_semi {field(_,x,_)}

channel_type:
    | t=(a='chan' b='<-' {_pseudo_token(a, b)} | a='<-' b='chan' {_pseudo_token(a, b)} | 'chan') x=type {chan_type(t, x)}

map_type: 'map' '[' x=type ']' y=type {map_type(x,y)}

qualified_ident: x=IDENT '.' y=IDENT { selector_expr(x, y) }

receiver: parameters

identifier_list: x=','.IDENT+ {x}
expression_list: ','.expression+

#include(grammar.expression.txt)

# control clause中限制的只有下面两种情况，这个不在限制中：
#  "x=literal_type y=literal_value {composite_lit(x,y)}"
composite_lit:
    | x=type_name_or_generic_type_instantiation? '{' y=','.keyed_element* ','? '}' {composite_lit(x, y)}

ellipsis: '...' {ellipsis(_)}
literal_type:
    | struct_type
    | '[' e=ellipsis ']' x=type {array_type(e,x)}
    | array_type
    | map_type

keyed_element:
    | x=expression ':' y=expression {key_value_expr(x,y)}
    | expression

array_type:
    | '[' ']' x=type {array_type(_,x)}
    | '[' e=ellipsis ']' x=type {array_type(e,x)}
    | '[' x=expression ']' y=type {array_type(x,y)}

method_spec: x=IDENT y=signature {field([x],y,_)}

struct_body: '{' x=field_decl_semi* '}' {field_list(x)}
struct_type:
    | 'struct' b=struct_body {struct_type(b)}

field_decl_semi: x=field_decl pseudo_semi {x}
field_decl:
    | x=identifier_list y=type z=tag? {field(x,y,z)}
    | x=embedded_field y=tag? {field(_,x,y)}
embedded_field:
    | '*' x=type_name_or_generic_type_instantiation {star_expr(x)}
    | t=type_name_or_generic_type_instantiation {t}
tag: x=STRING {basic_lit(x)}

pseudo_semi: ';' | &')'| &'}'
------------------------------------------------------------------------------------------------------------------------
#include(hack.go.txt)